//
// TrackingReminderNotification.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation


public class TrackingReminderNotification: JSONEncodable {
    public enum CombinationOperation: String { 
        case Mean = "MEAN"
        case Sum = "SUM"
    }
    /** id for the specific PENDING tracking remidner */
    public var id: Int32?
    /** id for the repeating tracking remidner */
    public var trackingReminderId: Int32?
    /** clientId */
    public var clientId: String?
    /** ID of User */
    public var userId: Int32?
    /** Id for the variable to be tracked */
    public var variableId: Int32?
    /** UTC ISO 8601 \&quot;YYYY-MM-DDThh:mm:ss\&quot;  timestamp for the specific time the variable should be tracked in UTC.  This will be used for the measurement startTime if the track endpoint is used. */
    public var pendingReminderTime: NSDate?
    /** Default value to use for the measurement when tracking */
    public var defaultValue: Float?
    /** String identifier for the sound to accompany the reminder */
    public var reminderSound: String?
    /** True if the reminders should appear as a popup notification */
    public var popUp: Bool?
    /** True if the reminders should be delivered via SMS */
    public var sms: Bool?
    /** True if the reminders should be delivered via email */
    public var email: Bool?
    /** True if the reminders should appear in the notification bar */
    public var notificationBar: Bool?
    /** When the record in the database was last updated. Use UTC ISO 8601 \&quot;YYYY-MM-DDThh:mm:ss\&quot;  datetime format. Time zone should be UTC and not local. */
    public var updatedAt: NSDate?
    /** Name of the variable to be used when sending measurements */
    public var variableName: String?
    /** Name of the variable category to be used when sending measurements */
    public var variableCategoryName: String?
    /** Abbreviated name of the unit to be used when sending measurements */
    public var unitAbbreviatedName: String?
    /** The way multiple measurements are aggregated over time */
    public var combinationOperation: CombinationOperation?

    public init() {}

    // MARK: JSONEncodable
    func encodeToJSON() -> AnyObject {
        var nillableDictionary = [String:AnyObject?]()
        nillableDictionary["id"] = self.id?.encodeToJSON()
        nillableDictionary["trackingReminderId"] = self.trackingReminderId?.encodeToJSON()
        nillableDictionary["clientId"] = self.clientId
        nillableDictionary["userId"] = self.userId?.encodeToJSON()
        nillableDictionary["variableId"] = self.variableId?.encodeToJSON()
        nillableDictionary["pendingReminderTime"] = self.pendingReminderTime?.encodeToJSON()
        nillableDictionary["defaultValue"] = self.defaultValue
        nillableDictionary["reminderSound"] = self.reminderSound
        nillableDictionary["popUp"] = self.popUp
        nillableDictionary["sms"] = self.sms
        nillableDictionary["email"] = self.email
        nillableDictionary["notificationBar"] = self.notificationBar
        nillableDictionary["updatedAt"] = self.updatedAt?.encodeToJSON()
        nillableDictionary["variableName"] = self.variableName
        nillableDictionary["variableCategoryName"] = self.variableCategoryName
        nillableDictionary["unitAbbreviatedName"] = self.unitAbbreviatedName
        nillableDictionary["combinationOperation"] = self.combinationOperation?.rawValue
        let dictionary: [String:AnyObject] = APIHelper.rejectNil(nillableDictionary) ?? [:]
        return dictionary
    }
}
